<!doctype html><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,minimal-ui"><title>Programação orientada a objetos na JavaScript</title><link rel=stylesheet href=assets/css/github-markdown.css><link rel=stylesheet href=assets/css/pilcrow.css><link rel=stylesheet href=assets/css/hljs-github.min.css><article class=markdown-body><h1 id=programação-orientada-a-objetos-na-javascript><a class=header-link href=#programação-orientada-a-objetos-na-javascript></a>Programação orientada a objetos na JavaScript</h1><h2 id=o-que-é-um-objeto?><a class=header-link href=#o-que-é-um-objeto?></a>O que é um objeto?</h2><p>Antes de entendermos o conceito de programação orientada a objetos, é válido compreender o que é um objeto.<p>Na JavaScript, o objeto pode ser interpretado como um dicionário, pois possui um conjunto de <code>key/value</code>, isto é, um conjunto de chaves e valores.<p>Por exemplo, se você deseja saber o que significa a palavra &quot;inspiração&quot;, procura por ela dentro de um dicionário para saber qual é o valor correspondente a ela. Na JS, o que ocorre é o mesmo. Se deseja saber qual é o valor de determinada chave, ou propriedade, de um objeto, faz referência a ela.<h3 id=sintaxe><a class=header-link href=#sintaxe></a>Sintaxe</h3><p>O objeto na JS é representado por chaves (<code>{}</code>). Seguindo o exemplo anterior, vamos supor que deseje criar uma variável cujo valor é um pequeno dicionário de palavras. Veja como poderia fazer:<pre class=hljs><code><span class=hljs-keyword>var</span> dicionario = {
  <span class=hljs-attr>programar</span>: <span class=hljs-string>'Significado de programar'</span>,
  café: <span class=hljs-string>'Significado de café'</span>,
  inspiração: <span class=hljs-string>'Significado de inspiração'</span>,
  <span class=hljs-attr>codificar</span>: <span class=hljs-string>'Signifcado de codificar'</span>
};</code></pre><p>Certo, temos nosso dicionário. Mas como procuramos o significado de &quot;inspiração&quot; dentro dele?<pre class=hljs><code><span class=hljs-keyword>var</span> significado = dicionario.inspiração;</code></pre><p>Se imprimirmos o valor da variável <code>significado</code> na tela ou no console, o valor obtido será &quot;Significado de inspiração&quot;. Bem mais simples do que folhear um dicionário, não acha?<p>Agora vamos para um outro exemplo. Vamos supor que deseje desenvolver um jogo de corrida. Para isto, cada carro possuirá as informações nome, velocidade atual e velocidade máxima e algumas ações, como acelerar ou frear. Como podemos fazer isso?<pre class=hljs><code><span class=hljs-keyword>var</span> carro1 = {
  <span class=hljs-attr>nome</span>: <span class=hljs-string>'Carro 1'</span>,
  <span class=hljs-attr>velocidadeAtual</span>: <span class=hljs-number>0</span>,
  <span class=hljs-attr>velocidadeMaxima</span>: <span class=hljs-number>220</span>,
  <span class=hljs-attr>acelerar</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>valor</span>) </span>{
    <span class=hljs-keyword>if</span> (<span class=hljs-keyword>this</span>.velocidadeAtual + valor &lt;= <span class=hljs-keyword>this</span>.velocidadeMaxima) {
      <span class=hljs-keyword>this</span>.velocidadeAtual += valor;
    }
  },
  <span class=hljs-attr>frear</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>valor</span>) </span>{
    <span class=hljs-keyword>if</span> (valor &amp;&amp; <span class=hljs-keyword>this</span>.velocidadeAtual - valor &gt;= <span class=hljs-number>0</span>) {
      <span class=hljs-keyword>this</span>.velocidadeAtual -= valor;
    } <span class=hljs-keyword>else</span> {
      <span class=hljs-keyword>this</span>.velocidadeAtual = <span class=hljs-number>0</span>;
    }
  }
};</code></pre><p>Certo, agora estamos com um objeto um pouco diferente: ele possui propriedades e métodos. O que difere um método de uma propriedade é que seu valor é uma função. Ou seja, métodos realizam ações, podendo modificar as propriedades do objeto ao qual fazem parte. No nosso exemplo, o método <code>acelerar</code> acessa as propriedades <code>velocidadeAtual</code> e <code>velocidadeMaxima</code>, verifica se a velocidade do carro pode ser aumentada e, se sim, altera o valor da <code>velocidadeAtual</code>, acrescentando o valor que passamos como argumento.<p>Na prática, poderíamos utilizar o código acima da seguinte forma para testar os comandos:<pre class=hljs><code>carro1.acelerar(<span class=hljs-number>20</span>); <span class=hljs-comment>// Altera a velocidade para 20</span>
carro1.acelerar(<span class=hljs-number>25</span>); <span class=hljs-comment>// Altera a velocidade para 45</span>
carro1.frear(<span class=hljs-number>10</span>); <span class=hljs-comment>// Altera a velocidade para 35</span></code></pre><p>Agora, preste atenção a um detalhe:<pre class=hljs><code><span class=hljs-keyword>if</span> (<span class=hljs-keyword>this</span>.velocidadeAtual + valor &lt;= <span class=hljs-keyword>this</span>.velocidadeMaxima) {
  <span class=hljs-keyword>this</span>.velocidadeAtual += valor;
}</code></pre><p>Por que utilizamos a palavra-chave <code>this</code> antes do nome da propriedade que desejamos ler ou alterar? Porque propriedades e métodos são dependentes do objeto ao qual fazem parte. Portanto, se escrevêssemos apenas <code>velocidadeAtual</code>, o nosso interpretador buscaria por uma variável com este nome ao invés da propriedade dentro do objeto. Isso quer dizer que sempre devemos utilizar a seguinte sintaxe para ler propriedades de dentro do objeto:<p><code>this.nomeDaPropriedade;</code><p>Mas, para ler uma propriedade do objeto do lado de fora deste, devemos utilizar a sintaxe:<p><code>nomeDoObjeto.nomeDaPropriedade;</code><h2 id=quais-as-vantagens-de-um-código-orientado-a-objetos?><a class=header-link href=#quais-as-vantagens-de-um-código-orientado-a-objetos?></a>Quais as vantagens de um código orientado a objetos?</h2><p>A vantagem já começa pelo fato de que tudo na JS é um objeto, o que inclui o escopo global onde escrevemos o nosso código. Quer ver?<pre class=hljs><code><span class=hljs-built_in>console</span>.log(<span class=hljs-string>'Algum texto aqui'</span>);
<span class=hljs-keyword>this</span>.console.log(<span class=hljs-string>'Outro texto aqui'</span>);</code></pre><p>Se rodar este código e abrir o console, as duas linhas irão aparecer, incluindo aquela que possui a palavra-chave <code>this</code> antes da referência ao <code>console</code>.<p>Até o fim desta leitura, irá perceber dois fatores essenciais para uma programação mais confortável: legibilidade e automatização.<p>Mas as vantagens se tornam perceptíveis ao passo que o nosso código aumenta. No exemplo do jogo de carros, vimos que controlar as propriedades do carro de dentro do objeto é realmente muito eficaz. Mas e se você tivesse que criar 10 carros? Aí o código ficaria bem extenso, sem considerar ainda que seria fácil cometer erros, como escrever errado o nome de alguma propriedade ou método.<p>Como podemos contornar essa situação?<h2 id=classes><a class=header-link href=#classes></a>Classes</h2><p>As classes permitem que criemos um modelo de objeto que representará uma entidade específica no nosso código.<pre class=hljs><code><span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Carro</span> </span>{
  <span class=hljs-keyword>constructor</span>(nome) {
    <span class=hljs-keyword>this</span>.nome = nome;
    <span class=hljs-keyword>this</span>.velocidadeMaxima = <span class=hljs-number>220</span>;
    <span class=hljs-keyword>this</span>.velocidadeAtual = <span class=hljs-number>0</span>;
  }

  acelerar(valor) {
    <span class=hljs-keyword>if</span> (<span class=hljs-keyword>this</span>.velocidadeAtual + valor &lt;= <span class=hljs-keyword>this</span>.velocidadeMaxima) {
      <span class=hljs-keyword>this</span>.velocidadeAtual += valor;
    }
  }

  frear(valor) {
    <span class=hljs-keyword>if</span> (valor &amp;&amp; <span class=hljs-keyword>this</span>.velocidadeAtual - valor &gt;= <span class=hljs-number>0</span>) {
      <span class=hljs-keyword>this</span>.velocidadeAtual -= valor;
    } <span class=hljs-keyword>else</span> {
      <span class=hljs-keyword>this</span>.velocidadeAtual = <span class=hljs-number>0</span>;
    }
  }
}</code></pre><p>Vamos analisar o código acima. Ao invés de criar as propriedades diretamente, definimos elas dentro de uma função construtora. O <code>constructor</code> é disparado assim que a instância é criada. Ou seja, quando criarmos um novo carro utilizando esta classe, o código dentro de <code>constructor</code> será rodado. Isto quer dizer que é lá que devemos definir as propriedades que farão parte do nosso objeto e seus respectivos valores.<p>Também é possível definir parâmetros no <code>constructor</code>:<pre class=hljs><code>  ...
  constructor(nome) {
    <span class=hljs-keyword>this</span>.nome = nome;
  ...</code></pre><p>Agora, se quisermos criar um novo carro, basta invocar a nossa classe utilizando a palavra-chave <code>new</code>:<pre class=hljs><code><span class=hljs-keyword>var</span> carro1 = <span class=hljs-keyword>new</span> Carro(<span class=hljs-string>'Carro 1'</span>);</code></pre><p>Podemos alterar os valores do objeto ou utilizar seus métodos da seguinte maneira:<pre class=hljs><code>carro1.nome = <span class=hljs-string>'Impala'</span>;
carro1.acelerar(<span class=hljs-number>100</span>);</code></pre><p>Assim, é possível criar quantas instâncias da classe <code>Carro</code> forem necessárias utilizando apenas uma linha para cada carro:<pre class=hljs><code><span class=hljs-keyword>var</span> carro2 = <span class=hljs-keyword>new</span> Carro(<span class=hljs-string>'Fusca'</span>);
<span class=hljs-keyword>var</span> carro3 = <span class=hljs-keyword>new</span> Carro(<span class=hljs-string>'Opala'</span>);</code></pre><p>Lembra daquele código grande que escrevemos no princípio para criar um carro? Agora ele foi diminuído para apenas uma linha!<p>Podemos modificar outras propriedades no nosso <code>constructor</code>. Todo jogo de corrida legal possui carros com velocidades diferentes. Vamos deixar o nosso assim também?<p>Podemos deixar que a velocidade máxima seja personalizada e garantir um valor padrão, para quando nenhum outro for passado. Veja:<pre class=hljs><code>  ...
  constructor(nome, velocidadeMaxima) {
    <span class=hljs-keyword>this</span>.nome = nome;
    <span class=hljs-keyword>this</span>.velocidadeMaxima = velocidadeMaxima || <span class=hljs-number>220</span>;
    ...</code></pre><p>Nossos carros já podem ser criados desta forma:<pre class=hljs><code><span class=hljs-keyword>var</span> carro1 = <span class=hljs-keyword>new</span> Carro(<span class=hljs-string>'Carro lento'</span>, <span class=hljs-number>60</span>);
<span class=hljs-keyword>var</span> carro2 = <span class=hljs-keyword>new</span> Carro(<span class=hljs-string>'Carro com velocidade padrão'</span>);
<span class=hljs-keyword>var</span> carro3 = <span class=hljs-keyword>new</span> Carro(<span class=hljs-string>'Carro veloz'</span>, <span class=hljs-number>300</span>);</code></pre><p>As velocidades máximas destes carros serão, respectivamente: 60, 220 e 300.<h3 id=o-que-significa-ser-um-carro?><a class=header-link href=#o-que-significa-ser-um-carro?></a>O que significa ser um carro?</h3><p>As classes devem sempre representar uma entidade. No nosso caso, a entidade é o carro. Ao criar uma classe baseando-se em uma entidade - neste caso o carro -, pare e pense:<ul class=list><li>O que significa ser um carro?<li>O que um carro tem?<li>O que um carro faz?</ul><p>As propriedades e métodos da classe serão instanciadas em todos os objetos por ela criados. Portanto, só coloque na classe <code>Carro</code> aquilo que todos os carros do jogo irão possuir.<p>Em alguns casos, porém, você terá carros com as mesmas propriedades e métodos da classe <code>Carro</code>, mas com algumas características a mais.<p>Por exemplo, vamos supor que alguns carros tenham a opção turbo, que faz com que o carro vá direto à sua velocidade máxima. Estes carros continuarão tendo as mesmas propriedades e métodos que os outros, entretanto terão também o método <code>turbo</code>. E agora? Como resolvemos isso?<h3 id=extends><a class=header-link href=#extends></a>Extends</h3><p>Para criar carros com a opção turbo, podemos criar uma nova classe que irá estender a classe <code>Carro</code>:<pre class=hljs><code><span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Turbo</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>Carro</span> </span>{
  turbo() {
    <span class=hljs-keyword>this</span>.velocidadeAtual = <span class=hljs-keyword>this</span>.velocidadeMaxima;
  }
}</code></pre><p>Que tal criarmos um novo carro com a opção turbo?<pre class=hljs><code><span class=hljs-keyword>var</span> carro1 = <span class=hljs-keyword>new</span> Turbo(<span class=hljs-string>'Carro com turbo'</span>, <span class=hljs-number>320</span>);
carro1.turbo();
carro1.frear(<span class=hljs-number>20</span>);</code></pre><p>A velocidade atual de <code>carro1</code> é 300.<blockquote><p>Tanto os carros criados diretamente com o comando <code>new Carro()</code> como os criados com <code>new Turbo()</code> são instâncias da classe <code>Carro</code>. Isto acontece porque <code>Carro</code> é a classe mãe de <code>Turbo</code>. Ou seja, independente de como as instâncias forem criadas, todos os objetos representarão carros.</blockquote><h2 id=conclusão><a class=header-link href=#conclusão></a>Conclusão</h2><p>Escrever um código orientado a objetos pode trazer mais praticidade ao desenvolvedor:<ul class=list><li><strong>O código fica mais organizado</strong>, pois declaramos propriedades e métodos dentro dos escopos onde eles serão utilizados, isto é, suas classes. Assim, fica muito mais fácil encontrar a parte do código que precisa ser editada.<li>A <strong>redução do número de linhas de código</strong> é claramente perceptível, uma vez que podemos instanciar classes com apenas uma linha de código.<li>Ao invés de criar diversas funções e passar nossos objetos como parâmetros para elas, fazemos com que as ações modificadoras de conteúdo do objeto ocorram dentro dele mesmo. Deste modo, <strong>são os objetos que orquestram o código</strong>, sem necessitar de chamadas de funções externas.</ul><blockquote><p>Vale lembrar que classes, na sintaxe que vimos aqui, são um recurso novo da JS, o que quer dizer que muitos navegadores ainda não as suportam. Para contornar esta situação, você pode instalar pacotes do Node que adaptam o seu código para os navegadores. Um deles é o <a href=http://browserify.org/ >Browserify</a>.</blockquote></article>
